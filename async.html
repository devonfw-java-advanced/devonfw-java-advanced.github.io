<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>devonfw Java Advanced Training - Asynchronous</title>

    <link rel="stylesheet" href="assets/css/reset.css" />
    <link rel="stylesheet" href="assets/css/reveal.css" />
    <link rel="stylesheet" href="assets/css/theme/black.css" />
    <link rel="stylesheet" href="assets/css/slides.css" />

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="assets/lib/css/monokai.css" />

    <link rel="icon" href="favicon.ico" />

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement("link");
      link.rel = "stylesheet";
      link.type = "text/css";
      link.href = window.location.search.match(/print-pdf/gi)
        ? "assets/css/print/pdf.css"
        : "assets/css/print/paper.css";
      document.getElementsByTagName("head")[0].appendChild(link);
    </script>
  </head>
  <body>
    <div class="reveal training">
      <div class="slides">
        <section>
          <h2 class="no-text-transform" style="color: #5382a1">Asynchronous</h2>
          <h2>
            <img
              alt="Java logo"
              style="height: 17rem"
              class="no-border no-margin no-background"
              src="assets/img/java-logo.svg"
            />&nbsp;
          </h2>
        </section>
        <section>
          <h2>Agenda</h2>
          <ul>
            <li>Asynchronous programming in Java</li>
            <li>Hands-on example</li>
            <li>Spring's <code class="highlight">@Async</code> annotation</li>
            <li>
              Spring's support for the
              <span class="highlight">Servlet 3.0</span> asynchronous processing
            </li>
            <li>Hands-on example</li>
          </ul>
        </section>
        <section>
          <h3><span class="highlight">π</span> and the Monte Carlo method</h3>
          <img
            alt="PI and Monce Carlo"
            style="height: 17rem"
            class="no-border no-margin no-background"
            src="assets/img/monte-carlo-pi-220px-Pi_30K.gif"
          />
          <ul>
            <li>
              <span
                >Given that the ratio of their areas is π / 4 , the value of π
                can be approximated using a Monte Carlo method.</span
              >
            </li>
          </ul>
        </section>
        <section>
          <h3>Runnable vs. Callable</h3>
          <ul>
            <li>
              The <code class="highlight">Runnable</code> is a functional
              interface and has a single
              <code class="highlight">run()</code> method which doesn't accept
              any parameters and does not return any values:
              <pre><code class="hljs java" data-trim data-line-numbers>
public interface Runnable {
  public void run();
}
              </code></pre>
            </li>
            <li>
              The <code class="highlight">Callable</code> is a generic interface
              containing a single <code class="highlight">call()</code> method –
              which returns a value <code class="highlight">V</code>:
              <pre><code class="hljs java" data-trim data-line-numbers>
public interface Callable&lt;V&gt; {
  V call() throws Exception;
}
              </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>Future</h3>
          <ul>
            <li>
              A Future represents the result of an asynchronous computation:
              <pre><code class="hljs java" data-trim data-line-numbers>
public interface Future&lt;V&gt; {
  boolean cancel(boolean mayInterruptIfRunning);
  boolean isCancelled();
  boolean isDone();
  V get() throws InterruptedException, ExecutionException;
  V get(long timeout, TimeUnit unit)
      throws InterruptedException, ExecutionException,
             TimeoutException;
}
              </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>Example 1/2</h3>
          <pre><code class="hljs java" data-trim data-line-numbers>
 interface PiService { Pi computePi(int timeToComputeInSeconds) }
 class App {
   ExecutorService exec = ...
   PiService ps = ...
   void show(int timeInSeconds) throws InterruptedException {
     Future&lt;Pi&gt; future = exec.submit(new Callable&lt;Pi&gt;() {
         public Pi call() { return ps.computePi(timeInSeconds);
     }});
     displayOtherThings(); // do other things while computing π
     try {
       displayText(future.get());
     } catch (ExecutionException ex) { }
   }
 }
					</code></pre>
        </section>
        <section>
          <h3>Example 2/2</h3>
          <ul>
            <li>
              The <code class="highlight">FutureTask</code> class is an
              implementation of <code class="highlight">Future</code> that
              implements <code class="highlight">Runnable</code>, and so may be
              executed by an <code class="highlight">Executor</code>.
            </li>
          </ul>
          <pre><code class="hljs java" data-trim data-line-numbers>
 FutureTask&lt;Pi&gt; future =
   new FutureTask&lt;String&gt;(new Callable&lt;Pi&gt;() {
     public Pi call() {
       return ps.computePi(timeInSeconds);
   }});
 e.execute(future);
					</code></pre>
        </section>

        <section>
          <h1>
            <img
              alt="Java logo"
              style="height: 17rem"
              class="no-border no-margin no-background"
              src="assets/img/java-logo.svg"
            />&nbsp;<span style="color: #5382a1">8</span>
          </h1>
        </section>

        <section>
          <h3>CompletableFuture</h3>
          <ul>
            <li>
              The <code class="highlight">Future</code> does not have any
              methods to combine the computations or handle possible errors.
            </li>
            <li>
              The <code class="highlight">CompletableFuture</code> implements
              the <code class="highlight">Future</code> and the
              <code class="highlight">CompletionStage</code>. The last interface
              defines the contract for an asynchronous computation step that we
              can combine with other steps.
            </li>
            <li>
              <code class="highlight">CompletableFuture</code> has about 50
              different methods for composing, combining, and executing
              asynchronous computation steps and handling errors.
            </li>
          </ul>
        </section>

        <section>
          <h3>Hands-on example</h3>
          <p>
            Repository on
            <a
              href="https://github.com/devonfw-java-advanced/concurrent"
              target="_blank"
              >github</a
            >
            contains branches:
          </p>
          <ul>
            <li>
              <a
                href="https://github.com/devonfw-java-advanced/concurrent/tree/step-0"
                target="_blank"
                >step-0</a
              >
              base version
            </li>
            <li>
              <a
                href="https://github.com/devonfw-java-advanced/concurrent/tree/step-1"
                target="_blank"
                >step-1</a
              >
              <span class="highlight">Future</span> and
              <span class="highlight">FutureTask</span>
            </li>
            <li>
              <a
                href="https://github.com/devonfw-java-advanced/concurrent/tree/step-2"
                target="_blank"
                >step-2</a
              >
              <span class="highlight">CompletableFuture</span>
            </li>
          </ul>
        </section>

        <section>
          <div>
            <img
              alt="Spring logo"
              style="height: 7rem"
              class="no-border no-margin no-background"
              src="assets/img/spring-framework-logo.svg"
            />
          </div>
          <h1>
            &nbsp;<span style="text-transform: none; color: #5fb832"
              >@Async</span
            >
          </h1>
        </section>
        <section>
          <pre><code class="hljs java" data-trim data-line-numbers>
@Service
public class PiSingleService {
  @Async
  public CompletableFuture&lt;Pi&gt; computePi(int timeInSeconds) {
    Pi pi = ...
    return CompletableFuture.completedFuture(pi);
  }
}
            </code></pre>
          <pre><code class="hljs java" data-trim data-line-numbers>
@Service
public class PiMultiService {
  @Autowired
  private PiSingleService ps;
  public List&lt;Pi&gt; computeMultiPis(int timeInSeconds) {
        return Stream.of(ps.computePi(timeInSeconds),
                         ps.computePi(timeInSeconds))
                .map(this::get).filter(Objects::nonNull)
                .collect(Collectors.toList());
    }
  private Pi get(CompletableFuture&lt;Pi&gt; f) {
    try { return f.get(); } catch (Exception e) { return null; }
  }
}
					</code></pre>
        </section>

        <section>
          <pre><code class="hljs java" data-trim data-line-numbers>
@Configuration
@EnableAsync
public class AsyncConfig {
  @Bean
  public Executor asyncExecutor() {
    ThreadPoolTaskExecutor exe = new ThreadPoolTaskExecutor();
    exe.setCorePoolSize(0);
    exe.setQueueCapacity(0);
    exe.setKeepAliveSeconds(10);
    exe.setThreadNamePrefix("async-");
    exe.initialize();
    return exe;
  }
}
					</code></pre>
        </section>
        <section>
          <div>
            <img
              alt="Spring logo"
              style="height: 7rem"
              class="no-border no-margin no-background"
              src="assets/img/spring-framework-logo.svg"
            />
          </div>
          <h5 style="margin: 0">
            <span style="text-transform: none; color: #5fb832"
              >Support for Servlet 3.0</span
            >
          </h5>
          <h5>
            <span style="text-transform: none; color: #5fb832"
              >asynchronous processing</span
            >
          </h5>
        </section>

        <section>
          <pre><code class="hljs java" data-trim data-line-numbers>
@RestController
public class PiRest {
    @Autowired
    private PiMultiService ps;

    @GetMapping("rest/pi")
    public Callable&lt;List&lt;Pi&gt;&gt; pi(
            @RequestParam(name = "timeInSeconds")
            int timeInSeconds) {
        return () -> {
            return ps.computeMultiPis(timeInSeconds);
        };
    }
}
            </code></pre>
        </section>
        <section>
          <pre><code class="hljs java" data-trim data-line-numbers>
@Configuration
public class MvcConfig {
  @Bean public Executor mvcExecutor() {
    return Executors.newCachedThreadPool();
  }
  @Bean public WebMvcConfigurer webMvcConfigurer() {
    return new WebMvcConfigurer() {
      @Override public void configureAsyncSupport(
          final AsyncSupportConfigurer configurer) {
          configurer.setTaskExecutor(
              new ConcurrentTaskExecutor(mvcExecutor()));
      }};
  }
}
            </code></pre>
        </section>
        <section>
          <h3>How it works... (1/2)</h3>
          <ul>
            <li>
              The controller returns a <code class="highlight">Callable</code>.
            </li>
            <li>
              Spring MVC calls
              <code class="highlight">request.startAsync()</code> and submits
              the <code class="highlight">Callable</code> to a
              <code class="highlight">TaskExecutor</code> for processing in a
              separate thread.
            </li>
            <li>
              Meanwhile, the
              <code class="highlight">DispatcherServlet</code> and all filters
              exit the Servlet container thread, but the response remains open.
            </li>
          </ul>
        </section>
        <section>
          <h3>How it works... (2/2)</h3>
          <ul>
            <li>
              Eventually the <code class="highlight">Callable</code> produces a
              result, and Spring MVC dispatches the request back to the Servlet
              container to complete processing.
            </li>
            <li>
              The <code class="highlight">DispatcherServlet</code> is invoked
              again, and processing resumes with the asynchronously produced
              return value from the <code class="highlight">Callable</code>.
            </li>
          </ul>
          <p style="text-align: right">
            <small
              >Taken from
              <a
                href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-processing"
                target="_blank"
                >Spring MVC documentation</a
              ></small
            >
          </p>
        </section>
        <section>
          <h3>Conclusions</h3>
          <p style="text-align: left">
            Introducing Spring <code class="highlight">@Async</code> calls (as
            in the code examples) results in almost
            <span class="highlight">2&nbsp;x&nbsp;faster</span> execution
            comparing to traditional synchronous processing.
          </p>
          <p style="text-align: left">
            Applying the Spring's support for the Servlet 3.0 asynchronous
            processing on top of the Spring's
            <code class="highlight">@Async</code> support
            <span class="highlight">does not bring performance improvement</span
            >.
          </p>
          <p style="text-align: left">
            Instead, the Servlet thread pool is not blocked, thus the
            application is <span class="highlight">more scalable</span>.
          </p>
        </section>

        <section>
          <h3>Hands-on example</h3>
          <p>
            Repository on
            <a
              href="https://github.com/devonfw-java-advanced/asynchronous"
              target="_blank"
              >github</a
            >
            contains branches:
          </p>
          <ul>
            <li>
              <a
                href="https://github.com/devonfw-java-advanced/asynchronous/tree/step-0"
                target="_blank"
                >step-0</a
              >
              base version
            </li>
            <li>
              <a
                href="https://github.com/devonfw-java-advanced/asynchronous/tree/step-1"
                target="_blank"
                >step-1</a
              >
              + asynchronicity in <span class="highlight">Servlet</span>
            </li>
            <li>
              <a
                href="https://github.com/devonfw-java-advanced/asynchronous/tree/step-2"
                target="_blank"
                >step-2</a
              >
              + asynchronicity in <span class="highlight">Service</span>
            </li>
          </ul>
        </section>
      </div>
    </div>

    <script src="assets/js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        hash: true,
        dependencies: [
          { src: "assets/plugin/markdown/marked.js" },
          { src: "assets/plugin/markdown/markdown.js" },
          { src: "assets/plugin/notes/notes.js", async: true },
          { src: "assets/plugin/highlight/highlight.js", async: true },
        ],
      });
    </script>
  </body>
</html>
